Проект по C++
=============

Rosbag: create option to filter for topics published by a node
-----------------------------------------

Issue на github: [rosbag: issue 819](https://github.com/ros/ros_comm/issues/819)

### В чем же цель?

Есть некие node -- какие-то процессы, умеющие что-то считать-делать. Иногда они записывают куда-то информацию о своих результатах/ошибках в файлик. Файлик в формате bag.

В каждом bag-файле могут быть сообщения, полученные при разных соединениях. Каждое соединение могло быть установлено с разными процессами node.

Есть утилита для командной строки rosbag. Она позволяет работать с bag-файлами. Запускать их, записывать и фильтровать сообщения в них. 

Хотелось в нее добавить ключик, позволяющий фильтровать сообщения по процессу node, их оставившему.

### Как решалось?

Много полезной информации про устройство файликов данного типа можно почитать [здесь](http://wiki.ros.org/Bags/Format/2.0). В частности, именно тут можно найти, что при установке соединения иногда прописывается callerId -- имя того самого node, с кем устанавливалось соединение. 
Далее для каждого сообщения прописывается id соединения, при котором оно получено.

Отсюда вывод: каждое сообщение на самом деле почти всегда знает, каким node было получено. Почитав [документацию](http://docs.ros.org/api/rosbag_storage/html/c++/namespacerosbag.html), можно понять, что всё необходимое уже есть. Можно открыть Bag от имени файла, создать от него View, проитерироваться по сообщениям файлика MessageInstance и сравнить их getCallerId() с заданным именем node.

Теперь, казалось бы, осталось найти, куда это вписать, и все будет хорошо. Но тут возникла проблема.

Основной код rosbag написан на питоне [rosbag_main.py](https://github.com/ros/ros_comm/blob/lunar-devel/tools/rosbag/src/rosbag/rosbag_main.py). Здесь происходит парсинг аргументов, вызов соответствующих функций, и т.д. Однако, оттуда иногда вызываются подпроцессы с помощью subprocess.Popen(). Как оказывается, эти подпроцессы -- это скомпилированные программы на плюсах, которые ищутся с помощью специальной утилиты roslib.packages.find_node. 

Однако все, что касалось фильтра сообщений, было написано только на питоне. Благодаря этому поддерживалась огромная функцииональность поиска: можно написать любое выражение на этом языке, внутри же оно просто вычисляется. Возникает новая проблема: как сохранить эту функциональность и добавить новую на другом языке?

Можно заметить, что сообщение однозначно задается своим topic и time -- темой и точным временем получения. Поэтому было решено передавать из новой написанной программки в программку на питоне темы и точное время сообщений, среди которых надо найти что-то еще. Это получилось сделать с помощью того же subprocess.Popen().

### Как собрать проект?

Для начала надо установить ROS вместе с исходным кодом. [Как это сделать](http://wiki.ros.org/kinetic/Installation/Source)

Дальше надо заменить папочку ./src/ros_comm/rosbag на папочку rosbag в этом репозитории и пересобрать проект.

Теперь можете запускать rosbag filter с ключом --node=NODE.

### Как тестировалось?

Проверялось все на файлах [отсюда](http://projects.csail.mit.edu/stata/downloads.php)
